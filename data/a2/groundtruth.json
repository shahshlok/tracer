[
    {
        "id": "NM_STATE_01",
        "category": "The Reactive State Machine",
        "name": "Spreadsheet View (Early Calculation)",
        "applicable_questions": [
            "Q1",
            "Q2"
        ],
        "explanation": "The student views variables as reactive constraints (like Excel cells). They compute the result formula _before_ reading input, expecting the result variable to automatically update when the input variables are later assigned values.",
        "student_thinking": "\"I'll define the formula `a = (v1-v0)/t` at the top so it's ready. Then I'll ask the user for the values. `a` will update automatically once `v0`, `v1`, and `t` have values.\"",
        "instructions_for_llm": {
            "Q1": "Initialize `v0=0, v1=0, t=0`. Compute `double a = (v1-v0)/t;` _before_ reading input. Then prompt and read real values. Print the _original_ `a` without recomputing.",
            "Q2": "Initialize variables to 0. Compute `cost` before input. Read inputs. Print stale `cost`."
        }
    },
    {
        "id": "NM_IO_01",
        "category": "The Anthropomorphic I/O Machine",
        "name": "Prompt-Logic Mismatch",
        "applicable_questions": [
            "Q1",
            "Q3"
        ],
        "explanation": "The student believes the program matches input values to variables based on the text of the `System.out.print` prompt, ignoring the actual execution order of `nextDouble()` calls.",
        "student_thinking": "\"I told the user 'Enter v0, then v1'. So even if I write `v1 = scan.nextDouble()` first, the computer knows the first number is meant for v0 because of my prompt.\"",
        "instructions_for_llm": {
            "Q1": "Print prompt \"Enter v0, v1, t: \". Then read in WRONG order: `double t = scan.nextDouble(); double v0 = scan.nextDouble(); double v1 = scan.nextDouble();`. Compute `(v1-v0)/t` using these incorrectly-assigned variables.",
            "Q3": "Print \"Enter x1...\" but read into y1 first. The logic should rely on the prompt text being true, while the code does the opposite."
        }
    },
    {
        "id": "NM_IO_02",
        "category": "The Anthropomorphic I/O Machine",
        "name": "The Ghost Read",
        "applicable_questions": [
            "Q1",
            "Q2",
            "Q3"
        ],
        "explanation": "The student believes calling `scanner.nextDouble()` is sufficient to 'register' the input. They do not assign the return value to a variable, leaving the variables (often initialized to 0) unchanged.",
        "student_thinking": "\"I called `scan.nextDouble()`, so the program got the number. It knows where to put it.\"",
        "instructions_for_llm": {
            "Q1": "Initialize `double v0 = 0...`. Call `scanner.nextDouble();` without assignment. Compute `(v1-v0)/t` using the zero values.",
            "Q3": "Initialize variables to 0. Call `scanner.nextDouble()` 4 times without assignment. Calculate distance."
        }
    },
    {
        "id": "NM_TYP_01",
        "category": "The Fluid Type Machine",
        "name": "Integer Division Blindness",
        "applicable_questions": [
            "Q1",
            "Q4"
        ],
        "explanation": "The student assumes the division operator `/` behaves like a calculator button regardless of operand types. They do not realize that dividing two integers results in truncation before any assignment to a double variable occurs.",
        "student_thinking": "\"Velocities and time are just numbers. I'll use `int` because it's simpler. If I assign the result to a `double`, Java will automatically include the decimals.\"",
        "instructions_for_llm": {
            "Q1": "Declare `int v0, v1, t;` and read them using `nextInt()`. Compute `double a = (v1 - v0) / t;` (no casting). Print `a`.",
            "Q4": "Declare `int side1, side2, side3`. Compute `double s = (side1 + side2 + side3) / 2;`."
        }
    },
    {
        "id": "NM_TYP_02",
        "category": "The Fluid Type Machine",
        "name": "Narrowing Cast in Division",
        "applicable_questions": [
            "Q1",
            "Q4"
        ],
        "explanation": "The student misplaces the cast when trying to fix integer division. They cast the _result_ of the division to double, instead of casting the operands _before_ division.",
        "student_thinking": "\"I know integer division is bad. So I'll put `(double)` in front of the calculation: `(double)(v1 - v0 / t)`. That turns the result into a decimal.\"",
        "instructions_for_llm": {
            "Q1": "Use `int` variables. Compute `double a = (double)((v1 - v0) / t);` (casting the result, not operands).",
            "Q4": "Compute `double s = (double)((side1 + side2 + side3) / 2);` using integer variables/literals."
        }
    },
    {
        "id": "NM_SYN_01",
        "category": "The Algebraic Syntax Machine",
        "name": "XOR as Power",
        "applicable_questions": [
            "Q3"
        ],
        "explanation": "The student believes the caret symbol `^` is the universal operator for exponentiation. They are unaware it performs bitwise XOR in Java.",
        "student_thinking": "\"In math, `x^2` means squared. I'll just write `diff^2` to square the difference. It's cleaner than `Math.pow`.\"",
        "instructions_for_llm": {
            "Q3": "Use `int` coordinates. Compute distance using `(x2-x1)^2 + (y2-y1)^2`. Use the `^` operator, do not use `Math.pow`."
        }
    },
    {
        "id": "NM_SYN_02",
        "category": "The Algebraic Syntax Machine",
        "name": "Precedence Blindness",
        "applicable_questions": [
            "Q1",
            "Q4"
        ],
        "explanation": "The student assumes visual grouping in mathematical formulas (like a long division bar) overrides programming language operator precedence.",
        "student_thinking": "\"The formula shows `v1 - v0` on top of `t`. Java sees the formula the same way I do, so I don't need extra parentheses. It knows to subtract before dividing.\"",
        "instructions_for_llm": {
            "Q1": "Implement the formula strictly as `double a = v1 - v0 / t;` (omitting parentheses).",
            "Q4": "Implement semi-perimeter as `double s = side1 + side2 + side3 / 2;`."
        }
    },
    {
        "id": "NM_API_01",
        "category": "The Void Machine",
        "name": "The Void Assumption",
        "applicable_questions": [
            "Q3"
        ],
        "explanation": "The student treats return-value methods as void commands that mutate arguments in place. They call `Math.sqrt(x)` without assigning the result, assuming `x` is updated.",
        "student_thinking": "\"I call `Math.sqrt(x)` to turn x into its square root. I don't need to say `x = ...` because the function changes it for me.\"",
        "instructions_for_llm": {
            "Q3": "Calculate `distSquared`. Call `Math.sqrt(distSquared);` on a line by itself. Then print `distSquared` as the final answer."
        }
    }
]